<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Lokaler Gemini Chatbot Test</title>
    <style>
      /**
       * Minimale CSS-Stile für eine einfache und übersichtliche Darstellung des Chat-Interfaces.
       * Diese Stile sind nur für diese Testseite relevant und nicht Teil des produktiven Widgets.
       */
      body { font-family: sans-serif; max-width: 600px; margin: 40px auto; }
      #chat-messages { height: 300px; border: 1px solid #ccc; overflow-y: scroll; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
      .message { padding: 5px 10px; margin-bottom: 5px; border-radius: 10px; max-width: 80%; }
      .bot-message { background-color: #f1f1f1; color: black; }
      .user-message { background-color: #007bff; color: white; text-align: right; margin-left: auto; }
      .loading { font-style: italic; color: #888; }
    </style>
</head>
<body>
    <h1>Shinkoko Lokaler Chatbot Test</h1>
    <p>Diese Seite dient zum Testen der Chatbot-Logik über den lokalen Proxy-Server (`server.js`).</p>
    <div id="chat-messages"></div>
    <input type="text" id="chat-input" placeholder="Frage hier eingeben..." style="width: 80%;">
    <button id="chat-send">Senden</button>

    <script>
        // --- Konfiguration ---

        /**
         * Die URL des lokalen Proxy-Servers.
         * Alle Anfragen werden an diesen Endpunkt gesendet, der sie dann an die Gemini API weiterleitet.
         */
        const PROXY_SERVER_URL = "https://kokoproxy.vercel.app/api/chat";

        /**
         * Ein optionaler geheimer Schlüssel zur Authentifizierung gegenüber dem Proxy-Server.
         * Dieser Wert muss mit dem `CHATBOT_SECRET` in der `.env`-Datei (für `server.js`) übereinstimmen.
         * Er wird im `X-Chatbot-Secret`-Header gesendet.
         */
        const CHATBOT_SECRET = "q69LXYabMcOezRxBGJs0Qj00zVlP0PCzwMM337r+tAuHbvDAVnluaq1dQdE5VvAXNA98fmNymh8G+VCRGvzVJmoTT";

        // --- DOM-Elemente ---
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');

        /**
         * Speichert den gesamten Konversationsverlauf im Format, das von der Gemini API erwartet wird.
         * Jedes Objekt im Array repräsentiert eine Nachricht mit einer Rolle ('user' oder 'model') und dem Inhalt.
         * Dieser Verlauf wird bei jeder neuen Nachricht an die API gesendet, um den Kontext zu erhalten.
         */
        const chatHistory = [];

        // --- Funktionen ---

        /**
         * Fügt eine Nachricht zum Chatfenster hinzu und aktualisiert den `chatHistory`.
         * @param {string} text - Der Text der Nachricht.
         * @param {string} className - Die CSS-Klasse, die der Nachricht zugewiesen wird (z.B. 'user-message', 'bot-message').
         */
        function addMessage(text, className) {
            // 1. Nachricht visuell im Chatfenster anzeigen.
            const msgDiv = document.createElement('div');
            msgDiv.textContent = text;
            msgDiv.className = `message ${className}`; // Wendet die entsprechenden CSS-Klassen an.
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Scrollt automatisch zum Ende des Chats.

            // 2. Rolle für die API basierend auf der CSS-Klasse bestimmen.
            const role = className.includes('user-message') ? 'user' : 'model';

            // 3. Nachricht zum `chatHistory` hinzufügen, wenn es sich nicht um eine temporäre Lade-Nachricht handelt.
            // Die API erwartet die Rolle des Nutzers als 'user' und die des Bots als 'model'.
            if (role === 'user') {
                chatHistory.push({ role: "user", parts: [{ text: text }] });
            } else if (role === 'model' && !className.includes('loading')) {
                chatHistory.push({ role: "model", parts: [{ text: text }] });
            }
        }

        /**
         * Sendet die Nachricht des Benutzers an den lokalen Proxy-Server und verarbeitet die Antwort.
         */
        async function sendMessage() {
            const message = chatInput.value.trim();
            if (message === '') return; // Ignoriert leere Nachrichten.

            // Benutzernachricht zum Chat hinzufügen und das Eingabefeld leeren.
            addMessage(message, 'user-message');
            chatInput.value = '';

            // Eine "tippt..."-Nachricht anzeigen, um dem Benutzer sofortiges Feedback zu geben.
            addMessage("Shinkoko-Bot tippt...", 'bot-message loading');

            try {
                // Sendet den gesamten Chat-Verlauf an den Proxy-Server.
                const response = await fetch(PROXY_SERVER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Chatbot-Secret': CHATBOT_SECRET // Fügt den Sicherheits-Header hinzu.
                    },
                    body: JSON.stringify({
                        history: chatHistory // Das komplette Verlaufs-Array wird im Body gesendet.
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP-Fehler: ${response.status}`);
                }

                const data = await response.json();

                // Die temporäre "tippt..."-Nachricht entfernen.
                document.querySelector('.loading').remove();
                // Die Antwort des Bots zum Chat hinzufügen.
                addMessage(data.answer, 'bot-message');

            } catch (error) {
                console.error("Fehler beim Senden der Nachricht:", error);
                document.querySelector('.loading')?.remove(); // Sicherstellen, dass die Lade-Nachricht auch im Fehlerfall entfernt wird.
                addMessage("Entschuldigung, der Chatbot ist momentan nicht erreichbar. Prüfen Sie die Konsole auf Fehler.", 'bot-message');
            }
        }

        // --- Event-Listener ---

        // Löst die `sendMessage`-Funktion aus, wenn der Senden-Button geklickt wird.
        chatSend.addEventListener('click', sendMessage);

        // Löst die `sendMessage`-Funktion aus, wenn im Eingabefeld die Enter-Taste gedrückt wird.
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // --- Initialisierung ---

        // Zeigt eine Startnachricht an, wenn die Seite geladen wird.
        addMessage("Hallo! Dies ist eine lokale Testumgebung für den Shinkoko Chatbot. Stellen Sie eine Frage, um zu beginnen.", 'bot-message');
    </script>
</body>
</html>
